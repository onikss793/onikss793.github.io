{"componentChunkName":"component---src-templates-post-template-js","path":"/posts/nodejs/","webpackCompilationHash":"d0242dd32f791f74bc90","result":{"data":{"markdownRemark":{"id":"451539c9-d450-5dec-9678-2a0f21bb1755","html":"<h2 id=\"nodejs란-무엇일까\"><a href=\"#nodejs%EB%9E%80-%EB%AC%B4%EC%97%87%EC%9D%BC%EA%B9%8C\" aria-label=\"nodejs란 무엇일까 permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Node.js란 무엇일까…?</h2>\n<p>Node.js는 싱글 스레드 기반으로 동작하는 고성능의 비동기 IO(Async / Non-Blocking IO)를 지원하는 네트워크 서버로 Google Chrome V8 엔진을 사용했으며, Javasccript, Event Loop를 사용한다.</p>\n<h2 id=\"nodejs의-장점은\"><a href=\"#nodejs%EC%9D%98-%EC%9E%A5%EC%A0%90%EC%9D%80\" aria-label=\"nodejs의 장점은 permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Node.js의 장점은…</h2>\n<p>javascript 기반이라 Front End 개발자도 손쉽게 서버 프로그래밍을 할 수 있다. 언어를 굳이 바꿀 필요도, 기술셋을 굳이 나눌 필요도 없이, FE/BE의 기술 통합에 유용하게 사용될 수 있다.</p>\n<p>Socket.io를 이용한 웹 push 구현이 매우 쉽다.</p>\n<h6 id=\"socketio란-리얼타임-웹-어플리케이션을-위한-자바스크립트-라이브러리이다-웹-클라이언트와-서버의-양방향-리얼타임-커뮤니케이션을-가능하게-한다-브라우저에서-구동되는-라이브러리와-서버에서-nodejs를-위한-라이브러리로-구성되어있다\"><a href=\"#socketio%EB%9E%80-%EB%A6%AC%EC%96%BC%ED%83%80%EC%9E%84-%EC%9B%B9-%EC%96%B4%ED%94%8C%EB%A6%AC%EC%BC%80%EC%9D%B4%EC%85%98%EC%9D%84-%EC%9C%84%ED%95%9C-%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8-%EB%9D%BC%EC%9D%B4%EB%B8%8C%EB%9F%AC%EB%A6%AC%EC%9D%B4%EB%8B%A4-%EC%9B%B9-%ED%81%B4%EB%9D%BC%EC%9D%B4%EC%96%B8%ED%8A%B8%EC%99%80-%EC%84%9C%EB%B2%84%EC%9D%98-%EC%96%91%EB%B0%A9%ED%96%A5-%EB%A6%AC%EC%96%BC%ED%83%80%EC%9E%84-%EC%BB%A4%EB%AE%A4%EB%8B%88%EC%BC%80%EC%9D%B4%EC%85%98%EC%9D%84-%EA%B0%80%EB%8A%A5%ED%95%98%EA%B2%8C-%ED%95%9C%EB%8B%A4-%EB%B8%8C%EB%9D%BC%EC%9A%B0%EC%A0%80%EC%97%90%EC%84%9C-%EA%B5%AC%EB%8F%99%EB%90%98%EB%8A%94-%EB%9D%BC%EC%9D%B4%EB%B8%8C%EB%9F%AC%EB%A6%AC%EC%99%80-%EC%84%9C%EB%B2%84%EC%97%90%EC%84%9C-nodejs%EB%A5%BC-%EC%9C%84%ED%95%9C-%EB%9D%BC%EC%9D%B4%EB%B8%8C%EB%9F%AC%EB%A6%AC%EB%A1%9C-%EA%B5%AC%EC%84%B1%EB%90%98%EC%96%B4%EC%9E%88%EB%8B%A4\" aria-label=\"socketio란 리얼타임 웹 어플리케이션을 위한 자바스크립트 라이브러리이다 웹 클라이언트와 서버의 양방향 리얼타임 커뮤니케이션을 가능하게 한다 브라우저에서 구동되는 라이브러리와 서버에서 nodejs를 위한 라이브러리로 구성되어있다 permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><em>socket.io란, 리얼타임 웹 어플리케이션을 위한 자바스크립트 라이브러리이다. 웹 클라이언트와 서버의 양방향 리얼타임 커뮤니케이션을 가능하게 한다. 브라우저에서 구동되는 라이브러리와 서버에서 Node.js를 위한 라이브러리로 구성되어있다.</em></h6>\n<p>다른 언어의 Framework도 Web Socket을 지원하기는 하지만, 브라우저의 종류나 버전에 따라 제한적으로 작동하는데 반해, Node.js의 경우, 브라우저의 종류에 따라 자동으로 push 메커니즘을 선택, 적용한다. 또한 이러한 메커니즘이 모두 추상회되어 있어서 개발자가 편리하게 사용할 수 있다.</p>\n<p>Non-Blocking IO를 지원하기 때문에 효율적이 CPU 활용이 가능하다. 일반적인 서버들은 IO 요청들을 보낸 뒤에 응답을 기다리고 있기 때문에, CPU의 효율이 좋지 않다. 하지만 Node.js의 경우에는 Non-Blocking IO 콘셉트를 사용하기 때문에 이를 Event-Loop에 던져놓고, 처리가 끝나면 이에 대한 응답을 받아처리한다.</p>\n<h2 id=\"nodejs의-작동-원리\"><a href=\"#nodejs%EC%9D%98-%EC%9E%91%EB%8F%99-%EC%9B%90%EB%A6%AC\" aria-label=\"nodejs의 작동 원리 permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Node.js의 작동 원리</h2>\n<p>Node.js의 작동원리를 간단하게 살펴보자면, Google Chrome V8 엔진의 Javascript 엔진을 기본으로 동작하며, Single Thread 기반으로, Event Loop(libuv)가 돌면서 요청을 처리한다. 만약 시스템적으로 Non-Blocking IO를 지원하지 않는 IO 호출이 있는 경우, 이를 비동기 처리 하기 위해, 내부의 Thread Pool(libio)를 별도로 이용해 처리한다. 그 위에 네트워크 프로토콜을 처리하는 Socket, Http 바인딩 모듈이 load되고, 맨 윗단에 Node.js에서 제공하는 Standard Library(File Handling, Conole, etc…)가 load된다.</p>\n<h3 id=\"async--non-blocking-io\"><a href=\"#async--non-blocking-io\" aria-label=\"async  non blocking io permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Async / Non-Blocking IO</h3>\n<p>먼저 동기식 IO의 경우, 예를 들어 File Write IO를 요청하면, 디스크에 파일 쓰기 요청을 하고, 디스크가 파일을 쓰는 동안 프로그램은 File Write 부분에 멈춰서 대기한다. 이를 Block 되었다고 한다. 파일을 쓰는 동안에는 CPU가 사용되지 않고 있기 때문에 비효율적이라고 할 수 있다.</p>\n<p>비동기식 IO의 경우에는 파일 쓰기 요청을 할 때, 파일 요청이 끝나면 호출 될 Callback 함수를 같이 넘긴다. 파일 쓰기 요청이 접수되면 프로그램은 이를 기다리지 않고 요청을 Event Loop로 던져 놓고 다음 코드로 계속해서 진행한다. 파일을 다 썻다면 함께 넘겼던 Callback함수가 호출되면서 다음 처리를 진행한다.</p>\n<h3 id=\"single-thread-model\"><a href=\"#single-thread-model\" aria-label=\"single thread model permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Single Thread Model</h3>\n<p>Tomcat, JBoss와 같은 웹어플리케이션 서버나 Apache와 같은 일반적인 웹서버는 Multi Process 또는 Multi Thread의 형태를 가지고 있다. 만약 여러 개의 요청이 들어온다고 가정하면 Thread의 갯수가 해당 서버가 한번에 처리할 수 있는 갯수가 될 것이다. 그렇게 된다면 제한적인 갯수로 요청을 처리할 수밖에 없게 된다.</p>\n<p>이러한 문제를 해결하기 위한 것이 Single Thread 기반의 비동기 서버이다. 하나의 Thread만을 사용해서 여러 Client로부터 오는 요청을 처리한다. 단, 비동기 방식의 IO요청을 던져놓고 다른 요청들을 처리하는 방식을 진행되기 때문에, 다시 말해, IO 작업을 기다리지 않고 여러 요청을 계속해서 처리한다.</p>\n<p>Node.js도 Single Thread만 사용하는 것이 아니라 내부적으로 Multi Thread Pool를 사용하기는 한다. 일부 비동기를 지원하지 않는 함수일 경우, 어쩔 수 없이 Blocking이 발생하게 된다. 이를 해결하기 위해 내부적으로 Thread Pool을 별도로 운영하면서 Blocking이 발생되지 않도록 한다 .</p>\n<h2 id=\"마무리\"><a href=\"#%EB%A7%88%EB%AC%B4%EB%A6%AC\" aria-label=\"마무리 permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>마무리…</h2>\n<p>Node.js의 경우 굉장이 가볍고 생산성이 높은 웹 개발 프레임워크이다. 간단하지만 대규모, 빠른 응답 시간을 요구로 하는 어플리케이션에 적합하다. 하지만 CPU 작업이 많은 어플리케이션에는 적당하지 않다. Single Thread이고 Javascript 자체가 빠른 언어가 아니기 때문에 CPU에 많은 과부하가 걸릴 경우 전체적인 응답시간이 지연될 수 있다.</p>\n<h3 id=\"ps-express\"><a href=\"#ps-express\" aria-label=\"ps express permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>ps. Express…?</h3>\n<p>Express란, Node.js 상에서 동작하는 웹 개발 프레임워크이다. Node.js의 핵심 모듈인 http와 Connect 컴포넌트를 기반으로 하는 웹 프레임워크이다. 이러한 컴포넌트가 미들웨어로 작동한다. 개발자들은 이러한 미들웨어를 통해 유연하고 필요한 라이브러리를 어떤 것이든 자유롭게 선택해서 사용할 수 있다.</p>\n<p>Node.js의 핵심 모듈을 정리해본다면 다음과 같다.</p>\n<ul>\n<li>HTTP Request Body Parse</li>\n<li>Cookie Parse</li>\n<li>Session Management</li>\n<li>URL / Http Request Method를 기반으로 한 Route 구성</li>\n<li>Data Type을 토대로 한 적절한 응답 Headers 구성</li>\n</ul>\n<p>Express.js를 이용하게 되면 이러한 기능을 사용할 수 있으며 동시에 MVC 형태의 구조를 사용할 수도 있고, REST API, Realtime Web-Application 등 다양한 기능의 어플리케이션을 만들 수 있다.</p>","fields":{"slug":"/posts/nodejs/","tagSlugs":["/tag/node-js/"]},"frontmatter":{"date":"2020.01.15","description":"Basics of Node.js","tags":["node.js"],"title":"Node.js","socialImage":""}}},"pageContext":{"isCreatedByStatefulCreatePages":false,"slug":"/posts/nodejs/"}}}