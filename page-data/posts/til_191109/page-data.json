{"componentChunkName":"component---src-templates-post-template-js","path":"/posts/til_191109/","webpackCompilationHash":"ab72ec5e64abe3a51e98","result":{"data":{"markdownRemark":{"id":"673cc22c-f6d6-5156-956a-b058466848c9","html":"<h2 id=\"mongo-db\"><a href=\"#mongo-db\" aria-label=\"mongo db permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><strong>Mongo DB</strong></h2>\n<ul>\n<li>Mongo DB는 대표적인 NoSQL 중 하나이다.</li>\n<li>NoSQL => Not Only SQL, 관계형 데이터 베이스처럼 고정된 스키마, JOIN이 존재하지 않는다.</li>\n<li>Document Oriented => 한 개 이상의 key-value pair로 이루어진 데이터 구조(객체의 형태)이다.</li>\n<li>동적 Schema => 하나의 Collection 안의 document기리 다른 Schema를 가질 수 있다.</li>\n<li>Collection => RDMS의 테이블과 비슷한 역할이지만, 동적인 Schema를 가진다.</li>\n</ul>\n<h3 id=\"명령어\"><a href=\"#%EB%AA%85%EB%A0%B9%EC%96%B4\" aria-label=\"명령어 permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><strong>명령어</strong></h3>\n<ul>\n<li>use <em><strong>database name</strong></em> : Database 생성, 이미 존재하는 경우엔 현존하는 데이터 베이스 사용(db 로 현재 사용 중인 데이터 베이스 확인 가능)</li>\n<li>db.<em><strong>colection</strong></em>.insert({ <strong><em>key</em></strong>: <strong><em>value</em></strong>, <strong><em>key</em></strong>: <strong><em>value</em></strong> }) : 데이터 베이스에 Document 추가</li>\n<li>db.dropDatabase() : Database를 제거할 때 사용(단, use <strong><em>database name</em></strong>으로 삭제하고자 하는 데이터 베이스를 먼저 선택해야 한다)</li>\n<li>\n<p>db.createCollection(<em><strong>name</strong></em>, <em><strong>[options]</strong></em>) : Collection 생성할 때 사용</p>\n<ul>\n<li>OPTIONS<br>\n<strong>capped</strong><br>\nBoolean<br>\ntrue => Capped collection 을 활성화<br>\nCapped collection => 고정된 크기(fixed size) 를 가진 컬렉션으로서, size 가 초과되면 가장 오래된 데이터를 덮어쓴다.<br>\n이 값을 true로 설정하면 size 값을 반드시 설정해야 한다.<br>\n<strong>autoIndex</strong><br>\nBoolean<br>\ntrue=> _id 필드에 index를 자동으로 생성<br>\n기본값은 false<br>\n<strong>size</strong><br>\nnumber<br>\nCapped collection 을 위해 해당 컬렉션의 최대 사이즈(maximum size)를 ~ bytes로 지정<br>\n<strong>max</strong><br>\nnumber<br>\n해당 컬렉션에 추가할 수 있는 최대 갯수를 설정</li>\n</ul>\n</li>\n<li>db.<em><strong>collection name</strong></em>.drop() : Collection 제거할 때 사용</li>\n<li>db.<em><strong>collection name</strong></em>.insert(<em><strong>document</strong></em>) : Document를 추가</li>\n<li>db.<em><strong>collection name</strong></em>.find() : Collection의 Document 리스트를 확인할 때 사용</li>\n<li>db.<em><strong>collection name</strong></em>.find(criteria, jusOne) : Document를 생성</li>\n<li>db.<em><strong>collection name</strong></em>.remove(criteria) : Document를 제거(cretieria: {key: value}, jusOne: boolean)</li>\n</ul>\n<h4 id=\"query-연산자\"><a href=\"#query-%EC%97%B0%EC%82%B0%EC%9E%90\" aria-label=\"query 연산자 permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Query 연산자</h4>\n<p><strong>$eq</strong> : (equals) 주어진 값과 일치하는 값<br>\n<strong>$gt</strong> : (greater than) 주어진 값보다 큰 값<br>\n<strong>$gte</strong> : (greather than or equals) 주어진 값보다 크거나 같은 값<br>\n<strong>$lt</strong> : (less than) 주어진 값보다 작은 값<br>\n<strong>$lte</strong> : (less than or equals) 주어진 값보다 작거나 같은 값<br>\n<strong>$ne</strong> : (not equal) 주어진 값과 일치하지 않는 값<br>\n<strong>$in</strong> : 주어진 배열 안에 속하는 값<br>\n<strong>$nin</strong> : 주어빈 배열 안에 속하지 않는 값</p>\n<p><strong>$or</strong> : 주어진 조건중 하나라도 true 일 때 true<br>\n<strong>$and</strong> : 주어진 모든 조건이 true 일 때 true<br>\n<strong>$not</strong> : 주어진 조건이 false 일 때 true<br>\n<strong>$nor</strong> : 주어진 모든 조건이 false 일때 true</p>\n<p><strong>regex</strong><br>\n{ <field>: /pattern/<options> }<br>\noptions : i(대소문자 무시), m(anchor^ 사용 시 \\n이 있다면 무력화), x(whitespace 모두 무시), s(dot, 사용시 \\n 을 포함해서 매치)</p>\n<p><strong>where</strong>\n<code class=\"language-text\">db.articles.find( { $where: &quot;this.comments.length == 0&quot; } )</code>\narticles라는 collection에서 comments field가 비어있는 Document를 조회</p>","fields":{"slug":"/posts/til_191109/","tagSlugs":["/tag/project/","/tag/mongo-db/"]},"frontmatter":{"date":"2019.11.09","description":"Things I've learned through project","tags":["Project","Mongo DB"],"title":"TIL_191109","socialImage":""}}},"pageContext":{"isCreatedByStatefulCreatePages":false,"slug":"/posts/til_191109/"}}}