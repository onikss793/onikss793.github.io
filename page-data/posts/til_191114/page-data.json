{"componentChunkName":"component---src-templates-post-template-js","path":"/posts/til_191114/","webpackCompilationHash":"bade5310dfdc4ff5b635","result":{"data":{"markdownRemark":{"id":"32d4fda1-cd75-542a-9e1a-6fa5ad2df985","html":"<h2 id=\"data-structure\"><a href=\"#data-structure\" aria-label=\"data structure permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><strong>Data Structure</strong></h2>\n<p>데이터의 타입에 따라 효율적으로 저장하기 위한 도구이다.</p>\n<p>자료구조가 중요한 이유는 데이터 처리 자체가 중요하기 때문이다.</p>\n<p>Primitive: Integer, Float, String, Boolean</p>\n<p>Non-Primitive: Array, List, Tuple, Dictionary, Set, File</p>\n<h4 id=\"array\"><a href=\"#array\" aria-label=\"array permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Array</h4>\n<ul>\n<li>배열, 물리적으로 메모리에 순차적으로 저장이 된다. 순서가 있기 때문에, 지표인 index가 있고, 이를 통해 특정 자료에 바로 접근할 수 있다.</li>\n<li>순서가 있는 데이터를 저장할 때, 유용하다.</li>\n<li>물리적으로 저장되는 위치가 정해져 있기 때문에, 항상 일정량의 메모리를 차지하고 있다.</li>\n<li>만약 물리적 크기가 다 차게 되면, 더 큰 메모리를 확보한 후, 기존의 배열을 복사해서 새로운 요소를 추가한다.</li>\n<li>위의 것을 RESIZING이라고 하며, 이것이 단점이다.</li>\n<li>순차적 조회를 할 경우 속도가 빠르지 않다. O(N) : 해당 자료구조의 사이즈에 비례한다는 뜻.</li>\n<li>직접적 조회를 할 경우, O(1)</li>\n<li>순차적, 특정 요소, 사이즈 급변 X, 요소 삭제 X 일 경우에 사용하면 좋다.</li>\n</ul>\n<h4 id=\"tuple\"><a href=\"#tuple\" aria-label=\"tuple permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Tuple</h4>\n<ul>\n<li>순차적인 자료 구조이다.</li>\n<li>한번 생성하면 수정할 수가 없다.</li>\n<li>배열보다 메모리 효율적이다.</li>\n<li>튜플을 사용하지 않을 경우, 별도의 클래스를 생성해야 하는 수고를 덜 수 있다.</li>\n<li>테스트용, 즉 사용하긴 하지만 크게 중요하지 않은 데이터를 저장할 때 유용하다.</li>\n</ul>\n<h4 id=\"set\"><a href=\"#set\" aria-label=\"set permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Set</h4>\n<ul>\n<li>배열과 비슷한 순열 자료구조이다.</li>\n<li>하지만 순서가 없다.</li>\n<li>그래서 index도 없다.</li>\n<li>중복된 값이 허용되지 않는다.</li>\n<li>중복된 값을 제거하는 방식은, 입력된 값을 해싱한 후 자료 버켓에 넣고 중복된 값이 들어올 경우, 치환한다.</li>\n<li>치환하는 이유는 데이터의 identification의 문제는 쉬운 것이 아니다.</li>\n<li>class의 경우 default로 메모리의 주소를 기준으로 비교한다.</li>\n<li>특정한 값을 찾는 속도가 매우 빠르다.</li>\n<li>중복된 값을 골라내야 할 때, 빠른 조회가 필요할 때, 순서는 상과 없을 때 사용하면 좋다.</li>\n</ul>\n<h4 id=\"stack\"><a href=\"#stack\" aria-label=\"stack permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Stack</h4>\n<ul>\n<li>First in Last Out: 선입후출</li>\n<li>밑단에는 array로 구현되어 있다.</li>\n</ul>\n<h4 id=\"queue\"><a href=\"#queue\" aria-label=\"queue permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Queue</h4>\n<ul>\n<li>First in First out: 선입선출</li>\n<li>priority que: 중요도가 높은 큐를 먼저 뺄 때 사용</li>\n<li>밑단에는 array로 구현되어 있다.</li>\n</ul>\n<h4 id=\"tree\"><a href=\"#tree\" aria-label=\"tree permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Tree</h4>\n<ul>\n<li>어려운 트리구조도 많다.</li>\n<li>기본적으로는 binary 트리이다. 노드: 트리의 교점</li>\n<li>노드보다 값이 클 경우, 오른쪽, 작을 경우, 왼쪽으로 간다.</li>\n<li>리스트보다 훨씬 빠르다. O(logN) 속도</li>\n</ul>\n<h4 id=\"linked-list\"><a href=\"#linked-list\" aria-label=\"linked list permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Linked List</h4>\n<ul>\n<li>메모리가 충분하거나, 데이터의 정확한 사이즈를 모르겠거나, resizeing이 굉장히 큰 문제이거나, 중간에 삭제해야할 경우가 많을 때 사용하면 좋다.</li>\n</ul>","fields":{"slug":"/posts/til_191114/","tagSlugs":["/tag/project/","/tag/data-structure/"]},"frontmatter":{"date":"2019.11.14","description":"Things I've learned through project","tags":["Project","Data Structure"],"title":"TIL_191114","socialImage":""}}},"pageContext":{"isCreatedByStatefulCreatePages":false,"slug":"/posts/til_191114/"}}}