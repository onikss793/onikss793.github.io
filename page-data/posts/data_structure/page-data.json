{"componentChunkName":"component---src-templates-post-template-js","path":"/posts/data_structure/","webpackCompilationHash":"785fede6ed6e6d94d3ed","result":{"data":{"markdownRemark":{"id":"ac93d00c-c606-5f84-a4b4-2809cde64a3a","html":"<h2 id=\"data-structure\"><a href=\"#data-structure\" aria-label=\"data structure permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Data structure</h2>\n<h3 id=\"자료구조란-무엇인가\"><a href=\"#%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0%EB%9E%80-%EB%AC%B4%EC%97%87%EC%9D%B8%EA%B0%80\" aria-label=\"자료구조란 무엇인가 permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>자료구조란 무엇인가??</h3>\n<p>백앤드 API의 핵심은 데이터의 처리이다. 데이터를 처리하기 위해서는 데이터를 수집하고 저장해야 하는데, 어떻게 하면 효율적으로 저장할 수 있을까?</p>\n<p>만약 사과가 있는데 이것을 저장해야 한다. 그렇다면 어디에 저장하는 것이 좋을까? 그것은 목적에 맞게 달라질 것이다. 오랫동안 들고 다닐 것인지, 자주 꺼내 먹을 것인지, 갈아 먹을 것인지 등등…</p>\n<p>자료구조의 종류가 여러가지가 있는 것은 여러가지의 목적에 맞게 데이터를 사용하기 위해서이다.</p>\n<h3 id=\"자료구조의-분류\"><a href=\"#%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0%EC%9D%98-%EB%B6%84%EB%A5%98\" aria-label=\"자료구조의 분류 permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>자료구조의 분류</h3>\n<p>Primitive : <code class=\"language-text\">INTEGER, FLOAT, STRING, BOOLEAN</code></p>\n<p>일반적으로 자료구조라고 한다면 <code class=\"language-text\">Non Primitive: Array, List: Linear: Stack, Que, Non Linear: Tree, Tuple Dictionary Set, File</code> 를 말한다.</p>\n<h3 id=\"array배열\"><a href=\"#array%EB%B0%B0%EC%97%B4\" aria-label=\"array배열 permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Array(배열)</h3>\n<ul>\n<li>주로 이용하는 자료구조 중에 하나이다.</li>\n<li>자료들을 쭉 나열한 것이라고 볼 수 있다. 실제 메모리<code class=\"language-text\">(메모리는 빠르다. 하지만 용량이 크지 않다. 그래서 저장을 해야할 때는 하드 디스크에 저장을 한다. 자료구조는 메모리에서 사용된다)</code> 상에서 물리적으로 바로 옆에 저장이 된다. 그렇기 때문에 순서가 생긴다. 즉, Index가 생긴다는 의미이다.</li>\n<li>Index를 알고 있다면 해당 자료에 곧바로 접근할 수 있다. 또, Index가 있기 때문에 <code class=\"language-text\">slice</code>를 사용할 수 있다. 자료를 자른다는 의미이다.</li>\n<li>Array를 생성할 때, 중간에 다른 메모리가 끼여 있으면 안되기 때문에 항상 일정 분량의 메모리를 차지하고 있다. Default Size가 보통 정해져 있다. C와 같은 언어에서는 다 지정하게 되어 있다. Python도 C-Array를 사용할 수는 있다.</li>\n<li>만약 이미 할당되어 있는 Array의 크기보다 더 큰 Size의 자료를 저장하고자 할 때, Array Resizing이 일어난다. 이것은 높은 비용을 발생시키기 때문에 만약 Resizing이 자주 일어날 것 같은 자료라면, 애초에 Array를 사용하면 안된다.</li>\n<li>Array의 중간에 있는 자료를 지우게 될 경우, 뒤에 있는 모든 자료들을 물리적으로 이동시켜야 하기 때문에 비효율적일 수 있다. 만약 추가, 삭제가 빈번하게 일어난다면 Array를 사용하지 않는 것이 좋다.</li>\n</ul>\n<p><strong>Multi Dimensional Array</strong>\nArray의 요소가 Array가 되는 것이다. 바둑판, 매트릭스와 같은 2D, 2차원의 자료들에 많이 사용된다. 특정 메모리를 읽어들이는 것과 Index를 찾아 조회하는 것이 거의 비슷하기 때문에 굉장히 빠르고 효율적이다.</p>\n<p><strong>언제 쓰면 좋은가</strong></p>\n<ol>\n<li>순차적인 데이터를 저장할 때</li>\n<li>특정요소를 빠르게 읽어야 할 때</li>\n<li>데이터의 사이즈가 자주 변하지 않을 때</li>\n</ol>\n<h3 id=\"tuple튜플\"><a href=\"#tuple%ED%8A%9C%ED%94%8C\" aria-label=\"tuple튜플 permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Tuple(튜플)</h3>\n<ul>\n<li>배열과 마찬가지로 순차적으로 저장하는 자료구조이다.</li>\n<li>한번 바꾸면 변경할 수가 없다. (Immutable)</li>\n<li>주로 2, 3개의 소규모 데이터를 저장할 때 쓰인다.</li>\n<li>좌표를 나타낼 때 많이 쓰인다. class를 만들어 쓰는 것보다 효율적이다.</li>\n<li>\n<p>두개 이상의 값을 함수에서 반환할 때 쓰일 수 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"py\"><pre class=\"language-py\"><code class=\"language-py\"><span class=\"token keyword\">def</span> test<span class=\"token punctuation\">:</span>\n  <span class=\"token keyword\">return</span> <span class=\"token punctuation\">(</span><span class=\"token string\">'a'</span><span class=\"token punctuation\">,</span> <span class=\"token number\">8</span><span class=\"token punctuation\">)</span>\n\ns<span class=\"token punctuation\">,</span> n <span class=\"token operator\">=</span> test<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n<span class=\"token comment\"># s == 'a'</span>\n<span class=\"token comment\"># n == 8</span></code></pre></div>\n</li>\n<li>파이썬에는 네임드 튜플 같은 것도 있다(Named Tuple).</li>\n</ul>\n<h3 id=\"set\"><a href=\"#set\" aria-label=\"set permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Set</h3>\n<ul>\n<li>배열과 달리 순서가 없다.</li>\n<li>고로 Index가 없다.</li>\n<li>\n<p>중복된 값이 허용되지 않는다.</p>\n<div class=\"gatsby-highlight\" data-language=\"py\"><pre class=\"language-py\"><code class=\"language-py\">my_set <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span> <span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token number\">2</span><span class=\"token punctuation\">,</span> <span class=\"token number\">3</span><span class=\"token punctuation\">,</span> <span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token number\">2</span> <span class=\"token punctuation\">}</span>\nmy_set\n<span class=\"token comment\"># (1, 2, 3)</span>\n<span class=\"token keyword\">for</span> n <span class=\"token keyword\">in</span> my_set<span class=\"token punctuation\">:</span>\n  <span class=\"token keyword\">print</span><span class=\"token punctuation\">(</span>n<span class=\"token punctuation\">)</span>\n<span class=\"token comment\"># 1</span>\n<span class=\"token comment\"># 2</span>\n<span class=\"token comment\"># 3</span></code></pre></div>\n</li>\n<li>새로운 값이 넣었을 때, 이미 해당 값과 똑같은 값이 있다면 기존의 값을 치환해버린다.</li>\n<li>자동자 번호판, 주민번호, 전화번호부 등에 사용될 수 있다.</li>\n</ul>\n<p><strong>Big O Notation</strong> <code class=\"language-text\">O(N**2)</code> 의 경우 Set를 사용하면 훨씬 효율적일 수 있다.</p>\n<ul>\n<li>\n<p>그렇다면 Set는 왜 순서가 없을까?</p>\n<ul>\n<li>배열은 순서가 있고, Index가 있을 수 있도록 바로 옆에 저장된다.</li>\n<li>Set는 메모리 상에서 어떻게 저장되나</li>\n<li>예를 들어, 1을 저장한다고 가정한다.</li>\n<li>hashing을 통해 1을 해싱하고 메모리 상의 버켓에 1을 저장한다.</li>\n<li>뒤이어 2를 저장할 경우, 2를 해시값에 해당하는 메모리 버켓에 저장한다.</li>\n<li>만약 1을 다시 저장해야 한다면, 1을 해싱한 뒤, 해시값에 해당하는 메모리 버켓에 저장한다. 다시 말해, 이미 있는 1을 치환해버리는 것이다.</li>\n<li>그렇다면 해시값에 해당하는 메모리는 어떻게 설정되는 것일까?</li>\n<li>세트도 결국엔 배열로 구성되어 있다. 해시값을 메모리의 크기로 나누고, 그것을 메모리 안에서 인덱스로 사용한다.</li>\n<li>만약 해시 / 메모리 크기 가 같은 자료가 있다면? 그것을 해시 충돌이라고 한다. Hash Collision이라고 한다.</li>\n<li>파이선의 경우에는, 해시 충돌을 피하기 위해, 해시의 비트 값을 나눠서 계산해서 Index로 사용한다. 그리고 메모레 크기가 거의 다 찰 경우 알아서 Resizing을 한다.</li>\n</ul>\n</li>\n<li>Set는 조회가 빠르다. 만약 특정값을 찾고 싶고, Index를 모른다면, 배열의 경우 처음부터 모두 조회해야 한다. <code class=\"language-text\">O(N)</code> Set는 해당 값의 해시값을 구한 뒤에, 그 값을 Index로 이용해서 값을 바로 찾아낼 수 있다. <code class=\"language-text\">O(1)</code></li>\n</ul>\n<h3 id=\"hashmapdictionary\"><a href=\"#hashmapdictionary\" aria-label=\"hashmapdictionary permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>HashMap(Dictionary)</h3>\n<ul>\n<li><code class=\"language-text\">Key : Value</code> 의 형태로 저장하는 자료구조이다.</li>\n<li>해시 기반의 자료구조이기 때문에 순서가 없다.</li>\n<li>중복된 키로 저장할 수 없다. 만약 중복된 값이 키로 들어온다면 기존의 값을 Set처럼 치환해 저장된다.</li>\n</ul>\n<h3 id=\"stack\"><a href=\"#stack\" aria-label=\"stack permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Stack</h3>\n<ul>\n<li>Stack은 쌓는다는 개념과 비슷하다.</li>\n<li>Last In First Out</li>\n<li>마지막으로 들어가면 먼저 나온다.</li>\n<li>예를 들어, 브라우저의 뒤로가기</li>\n</ul>\n<h3 id=\"queue\"><a href=\"#queue\" aria-label=\"queue permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Queue</h3>\n<ul>\n<li>First In First Out</li>\n<li>예를 들어, 레스토랑에서 줄서기</li>\n<li>우선 순위 Queue라는 것도 있다. 예를 들어, 우선 순위가 있는 자료라면, 먼저 Out한다.</li>\n<li>우선 순위 Queue의 예로는 운영 체제의 프로세스가 있다. 예를 들어, 중요한 업데이트가 있다면 현재 CPU가 어떤 프로그램을 사용 중이던 간에 업데이트를 먼저 실행시킬 수 있다.</li>\n</ul>\n<p><code class=\"language-text\">Stack &amp; Queue 직접 구현해보기</code></p>\n<h3 id=\"tree-structure\"><a href=\"#tree-structure\" aria-label=\"tree structure permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Tree Structure</h3>\n<ul>\n<li>거꾸로 되어 있는 나무 형태를 말한다.</li>\n<li>Binary Decision을 사용한다. 예를 들어, Root로 7이 있다면, 3은 7의 왼쪽, 0는 7의 오른쪽으로 간다. 뒤이어 8이 올 경우 => 7의 오른쪽, 9의 왼쪽으로 간다.</li>\n<li>이것을 사용하는 이유는?? 탐색이 매우 빠르기 때문이다. 예를 들어, 8을 찾는다면 각각의 노드와 일치하는지를 검사하고, 만약 다르다면 큰지, 작은지만 검사하면 다음 노드로 넘어간다. Array보다 훨씬 빠르다. <code class=\"language-text\">O(Log N)</code></li>\n</ul>","fields":{"slug":"/posts/data_structure/","tagSlugs":["/tag/data-structure/"]},"frontmatter":{"date":"2020.01.08","description":"About data structure","tags":["Data Structure"],"title":"Data Structure","socialImage":""}}},"pageContext":{"isCreatedByStatefulCreatePages":false,"slug":"/posts/data_structure/"}}}