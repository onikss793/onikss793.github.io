<?xml version="1.0" encoding="UTF-8"?><rss xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"><channel><title><![CDATA[Blog by Daniel Yoo]]></title><description><![CDATA[Welcome to my Blog]]></description><link>https://github.com/onikss793/onikss793.github.io</link><generator>GatsbyJS</generator><lastBuildDate>Fri, 04 Oct 2019 12:09:06 GMT</lastBuildDate><item><title><![CDATA[Git commands]]></title><description><![CDATA[Basic Commands of terminal for git]]></description><link>https://github.com/onikss793/onikss793.github.io/posts/git_commands/</link><guid isPermaLink="false">https://github.com/onikss793/onikss793.github.io/posts/git_commands/</guid><pubDate>Thu, 03 Oct 2019 15:00:00 GMT</pubDate><content:encoded>&lt;h4 id=&quot;githubio-블로그-만들며서-썻던-git-commend들-정리&quot;&gt;&lt;a href=&quot;#githubio-%EB%B8%94%EB%A1%9C%EA%B7%B8-%EB%A7%8C%EB%93%A4%EB%A9%B0%EC%84%9C-%EC%8D%BB%EB%8D%98-git-commend%EB%93%A4-%EC%A0%95%EB%A6%AC&quot; aria-label=&quot;githubio 블로그 만들며서 썻던 git commend들 정리 permalink&quot; class=&quot;anchor&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;&lt;strong&gt;github.io 블로그 만들며서 썻던 git commend들 정리&lt;/strong&gt;&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;기본적인 터미널 단축키
cd: change directory 디렉토리로 이동할 수 있다.&lt;br&gt;
ls: listing directory 디렉토리에 있는 콘텐츠를 확인할 수 있다.&lt;br&gt;
open: file을 열 수 있다.&lt;br&gt;
mv: move file을 이동시킬 수 있다&lt;br&gt;
mkdir: make directory 새로운 디렉토리를 만들 수 있다.&lt;br&gt;
rmdir: 디렉토리를 제거할 수 있다 .&lt;br&gt;
rm -R: 현재 경로 안에 있는 디렉토리를 제거한다.&lt;br&gt;
sudo: 관리자로서 접근하여 명령할 수 있다. 매우 신중히 사용할 것.&lt;/li&gt;
&lt;li&gt;우선 Gatsby를 사용할 수 있도록 전역에 설치&lt;br&gt;
&lt;code class=&quot;language-text&quot;&gt;npm install -g gatsby-cli&lt;/code&gt;&lt;br&gt;
npm은 node.js package manager의 약자로 자바스크립트 언어를 위한 패키지 관리자이다. node를 다운받으면 같이 받을 수 있다.&lt;/li&gt;
&lt;li&gt;Gatsby의 theme 중 원하는 것의 source code를 가져온다.
&lt;code class=&quot;language-text&quot;&gt;gatsby new blog https://github.com/alxshelepenok/gatsby-starter-lumen&lt;/code&gt;&lt;br&gt;
추가적으로 facebook이 만든 yarn을 설치했다.&lt;br&gt;
yarn은 npm과 같은 자바스크립트 언어를 위한 패키지 관리자이다. npm의 취약한 저장소, 보안의 대안으로 나타났으며 npm보다 속도가 빠르다고 한다.&lt;/li&gt;
&lt;li&gt;블로그 설치 완료 후 localhost에서 확인&lt;br&gt;
yarn develop 혹은 npm run develop으로 localhost:8000에서 확인 가능하다.&lt;br&gt;
추가적으로 서버를 멈추고 싶다면 terminal 창을 끄거나 ctrl-c를 누르면 서버가 닫힌다.&lt;/li&gt;
&lt;li&gt;github에 repository를 만든다.
github에서 repository를 만든다. 여기서 주의할 점은 github 사용자 아이디와 같은 이름으로 naming해야 한다는 것이다. 그리고 사용자 이름 뒤에 github.io를 붙인다.&lt;br&gt;
&lt;code class=&quot;language-text&quot;&gt;username.github.io&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Source Code와 Repository를 연결한다. 설치한 blog파일에서 git을 시작한다.&lt;br&gt;
&lt;code class=&quot;language-text&quot;&gt;git init&lt;/code&gt; Repository의 주소와 연결한다.&lt;br&gt;
&lt;code class=&quot;language-text&quot;&gt;git remote add origin repository-url&lt;/code&gt;&lt;br&gt;
git add와 git commit을 통해 내용을 추가, 수정한 뒤 repository에 저장 가능하다.&lt;br&gt;
git add는 commit하기 전 추가할 사항들을 정하는 명령어로 add -p로 세부적인 사항을 하나하나 검토할 수도 있고, add . 으로 일괄적으로 추가할 수도 있다.&lt;br&gt;
git commit은 현재 branch로 push하기 전, 그러니까 저장소로 업로드하기 전에 메시지와 함께 작업 내역을 마지막으로 정리할 수 있는 명령어이다. commit -m으로 메시지를 남길 수 있고, commit -v를 이용하면 세부적인 변경사항을 확인할 수 있다.&lt;/li&gt;
&lt;li&gt;push와 deploy
branch는 보통 배포용인 master 외에 추가적으로 만들어 관리한다. 블로그이기 때문에 추가적인 branch 한 개를 더 만들어 내용을 업로드한다. 그러나 그 상태로는 아무리 push를 해도 배포에는 반영이 되지 않기 때문에, 자동으로 수행할 수 있는 &lt;code class=&quot;language-text&quot;&gt;&amp;quot;deploy&amp;quot;: &amp;quot;yarn run clean &amp;amp;&amp;amp; gatsby build &amp;amp;&amp;amp; gh-pages -d public -b master&lt;/code&gt; 명령어를 실행한다.&lt;br&gt;
이후 배포할 때는 &lt;code class=&quot;language-text&quot;&gt;yarn deploy&lt;/code&gt;를 명령어를 사용하면, 알아서 build, master에 push 그리고 deploy도 실행된다.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;​&lt;/p&gt;
&lt;h5 id=&quot;commands&quot;&gt;&lt;a href=&quot;#commands&quot; aria-label=&quot;commands permalink&quot; class=&quot;anchor&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;&lt;strong&gt;commands&lt;/strong&gt;&lt;/h5&gt;
&lt;ul&gt;
&lt;li&gt;git init: local에 새로운 repository를 만든다.&lt;/li&gt;
&lt;li&gt;git clone: local에 repository를 복사한다.&lt;/li&gt;
&lt;li&gt;git add: 상태에 1개 혹은 그 이상의 파일을 추가한다.&lt;/li&gt;
&lt;li&gt;git commit: 상태를 commit한다. repository에 접근하기 바로 전 단계&lt;/li&gt;
&lt;li&gt;git push { branch }: branch에 commit한 사항을 업로드 한다.&lt;/li&gt;
&lt;li&gt;git status: 현재의 상태&lt;/li&gt;
&lt;li&gt;git remote add origin: local에 있는 repository를 서버에 연결할 때 사용한다.&lt;/li&gt;
&lt;li&gt;git checkout: 해당 repository의 branch 리스트를 보여준다.&lt;/li&gt;
&lt;li&gt;git checkout { branchname }: 해당 branch로 이동한다.&lt;/li&gt;
&lt;li&gt;git log: commit한 기록들을 보여준다.&lt;/li&gt;
&lt;/ul&gt;</content:encoded></item><item><title><![CDATA[Enemy Rain]]></title><description><![CDATA[What I Learnded From Making Vanila Javascript Game]]></description><link>https://github.com/onikss793/onikss793.github.io/posts/enemy_rain</link><guid isPermaLink="false">https://github.com/onikss793/onikss793.github.io/posts/enemy_rain</guid><pubDate>Thu, 03 Oct 2019 15:00:00 GMT</pubDate><content:encoded>&lt;h4 id=&quot;개요&quot;&gt;&lt;a href=&quot;#%EA%B0%9C%EC%9A%94&quot; aria-label=&quot;개요 permalink&quot; class=&quot;anchor&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;&lt;strong&gt;개요&lt;/strong&gt;&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;배경화면을 띄운다.&lt;/li&gt;
&lt;li&gt;주인공이 배경 맨 아래에 위치하며 오른쪽, 왼쪽으로 이동할 수 있다.&lt;/li&gt;
&lt;li&gt;주인공이 왼쪽, 오른쪽으로 이동할 때마다 각각에 맞는 이미지로 변하며, 배경의 끝에 도달하면 더 이상 못 움직인다.&lt;/li&gt;
&lt;li&gt;귀신이 위에서 무작위로 내려온다.&lt;/li&gt;
&lt;li&gt;주인공이 귀신을 잡으면 귀신이 죽고 약 2초 뒤에 사라진다.&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&quot;css&quot;&gt;&lt;a href=&quot;#css&quot; aria-label=&quot;css permalink&quot; class=&quot;anchor&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;css&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;선수 지식: image-sprite - 여러 개의 이미지를 한 개의 파일에 모두 담아 관리하는 이미지를 말한다. 이렇게 하면 서버에서 각각의 이미지를 다운 받으면서 생기는 로딩 시간을 단축할 수 있고, 한 개의 파일만 관리하면 되기 때문에 유용하다.&lt;br&gt;
image-sprite를 사용하려면 background-postition을 사용해야 하는데 x축과 y축, width와 height를 이용해 하나의 이미지 파일에서 원하는 만큼만 보여지게 할 수 있다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&quot;javascript&quot;&gt;&lt;a href=&quot;#javascript&quot; aria-label=&quot;javascript permalink&quot; class=&quot;anchor&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;Javascript&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;가장 먼저 애를 먹었던 부분은 주인공과 귀신 모두 class를 사용해 생성해야 한다는 것이었다. 얼추 흉내는 냈지만 많은 부분을 그냥 function으로 실행했기 때문에 추후에 리팩토링하며 class로 변환하는 것을 연습해보아야겠다.&lt;/p&gt;
&lt;p&gt;먼저 주인공 class에는 &lt;code class=&quot;language-text&quot;&gt;this.hero&lt;/code&gt;라는 div를 만들었다. 그리고 &lt;code class=&quot;language-text&quot;&gt;createHero, heroLeft, heroRight&lt;/code&gt;라는 method를 만들었다.&lt;/p&gt;
&lt;p&gt;createHero(x)를 이용해 x축 값을 받아 배경 상에서 주인공이 어디에 위치할지를 정해주었고, 기본값으로 정면을 바라보고 있는 이미지를 주었다. &lt;code class=&quot;language-text&quot;&gt;this.hero.style.left = `${x}px`&lt;/code&gt;를 사용했는데, javascript내에서 style을 적용할 때, 저런 식으로 px을 따로 입력하는 것을 잊지 말자.
heroLeft()를 이용해 왼쪽을 바라보고 있는 이미지를, heroRight()를 이용해 오른쪽을 바라보고 있는 이미지를 정해주었다.&lt;/p&gt;
&lt;p&gt;귀신 class에는 &lt;code class=&quot;language-text&quot;&gt;createEnemy(x, y), killEnemy(), removeEnemy()&lt;/code&gt;를 사용했는데, 주인공 class와 유사한 기능을 가지고 있으며, 추가 사항으로는 귀신이 떨어지기 위한 y값과 죽었을 때의 이미지를 위한 killEnemy(), 사라질 때를 위한 removeEnemy()가 있다. 사라지는 것을 단순하게 display:none으로 구현했는데 이외에 분명 더 좋은 방법이 있을 것 같다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;게임을 실행하는 것을 크게 3 가지로 구분해보면,&lt;br&gt;
&lt;strong&gt;1. 첫째로 주인공을 만든 뒤 좌우로 이동시키는 것&lt;/strong&gt;&lt;br&gt;
&lt;strong&gt;2. 둘째로 귀신을 만든 뒤 아래로 내려오게 만드는 것&lt;/strong&gt;&lt;br&gt;
&lt;strong&gt;3. 셋째로 주인공과 귀신이 만났을 때 효과를 주는 것&lt;/strong&gt;&lt;br&gt;
이렇게 나눌 수 있을 것이다.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;우선 Hero라는 인스턴스를 한개 생성한다. 인스턴스의 갯수가 곧 개체 수의 갯수가 되는데, 주인공은 한 명이므로 한개만 생성한다.&lt;br&gt;
기존의 Hero class로 만들어 두었던 주인공 생성 method를 사용해 주인공을 화면에 띄운다. 이때의 x값은 default인 배경의 한 가운데이다.&lt;br&gt;
keyUp, keyDown event를 사용해 키보드 좌, 우 키를 눌렀을 때 주인공의 이미지를 좌, 우에 맞게 바꾸어준다(background-position-x를 사용한다). 이때 주의해야할 것은 게임이 진행되는 과정에서 애니매이션처럼 보이게 만들어주는 setInterval과의 관계이다. 키보드를 눌렀을 때 바라보는 이미지가 주어진 초에 맞추어 소위 reset되기 때문에 키가 눌려졌는지 여부를 알 수 있는 변수를 만들어 마치 on/off 같은 기능을 만드는 것이 중요하다.&lt;br&gt;
주인공이 한번의 key event에 움직일 px을 정해준 뒤, 각각의 key가 on/off일 때 맞추어 움직이는 함수를 생성한다.&lt;/p&gt;
&lt;p&gt;귀신을 생성하기에 앞서서 귀신이 생성될 random한 x축 값을 만드는 것이 우선이었다.&lt;br&gt;
최솟값, 최댓값의 범위 안에서 random한 상수를 생성하는 공식은 다음과 같다. &lt;code class=&quot;language-text&quot;&gt;Math.random() * (max - min) + min&lt;/code&gt; 만약 정수가 필요하다면 floor를 사용하면 된다.&lt;br&gt;
귀신을 생성할 때 의문이었던 것은, 귀신의 인스턴스가 많아질 경우, 어떻게 관리해야하나 하는 문제였다. 이를 해결하기 위해 배열을 만든 뒤 인스턴스 각각을 객체로 설정해 집어넣었다.&lt;br&gt;
귀신을 만들 때는 귀신의 y점이 배경의 높이보다 커질 경우, y는 0, x는 다시 randomise하게 설정했다.&lt;br&gt;
귀신이 떨어질 때 일괄적으로 떨어지는 속도가 재미가 없어보여, 곱하기를 통해 각각 속도가 다르도록 설정했다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;js&quot;&gt;&lt;pre class=&quot;language-js&quot;&gt;&lt;code class=&quot;language-js&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;fallEnemy&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;token keyword&quot;&gt;let&lt;/span&gt; fallingSpeed &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;4&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;

  &lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; adding &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;1.2&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;

  &lt;span class=&quot;token keyword&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token keyword&quot;&gt;let&lt;/span&gt; i &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt; i &lt;span class=&quot;token operator&quot;&gt;&amp;lt;&lt;/span&gt; enemyList&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;length&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt; i&lt;span class=&quot;token operator&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; enemy &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; enemyList&lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt;i&lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;

    enemy&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;y &lt;span class=&quot;token operator&quot;&gt;+=&lt;/span&gt; fallingSpeed&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;

    fallingSpeed &lt;span class=&quot;token operator&quot;&gt;*=&lt;/span&gt; adding&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;귀신과 부딫혔을 때를 계산하는 것이 제일 번거로웠는데, x축과 길이, y축과 높이를 계산하여 부딫혔을 때를 알 수 있다.&lt;/p&gt;
&lt;p&gt;가장 찝찝한 부분은 귀신과 주인공이 부딫히고 나서, 귀신이 죽은 이미지로 바뀐 후, 사라지는 과정이다. setInterval로 실행하는 전체 실행 함수인 init에 같이 넣게되면 이미지가 바뀜과 동시에 사라지는 문제가 생긴다. 그렇다고 따로 setInterval을 정하게 되면 순전히 타이밍에 따라서 2초를 꽉 채운 후, 사라지는 경우가 있고, 2초를 채우지 못하고 사라질 때도 있다. 분명 다른 방법이 있을 것 같다.&lt;/p&gt;</content:encoded></item><item><title><![CDATA[Westagram]]></title><description><![CDATA[What I learned From Instagram Clone Coding]]></description><link>https://github.com/onikss793/onikss793.github.io/posts/westagram/</link><guid isPermaLink="false">https://github.com/onikss793/onikss793.github.io/posts/westagram/</guid><pubDate>Thu, 03 Oct 2019 15:00:00 GMT</pubDate><content:encoded>&lt;h4 id=&quot;1-login-page&quot;&gt;&lt;a href=&quot;#1-login-page&quot; aria-label=&quot;1 login page permalink&quot; class=&quot;anchor&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;&lt;strong&gt;1. LogIn Page&lt;/strong&gt;&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;기본적인 Layout을 짜기 전에 margin과 padding 등을 일일이 계산하지 않도록 &lt;code class=&quot;language-text&quot;&gt;* { box-sizing: border-box }&lt;/code&gt; 를 사용했다.&lt;/li&gt;
&lt;li&gt;로그인을 전체적으로 감싸고 있는 div를 만든 뒤, Logo - Id&amp;#x26;Password Form - footer(비밀번호 찾기)로 구성했다. 그러나 다시 생각해보니 footer는 document의 맨 아래 위치한 section이기 때문에 적절치 않은 태그인 것 같다. div로 바꾸어도 무방할 듯하다.&lt;/li&gt;
&lt;li&gt;전체적인 정렬을 위해서 &lt;code class=&quot;language-text&quot;&gt;{ display: flex }&lt;/code&gt; 와 함께 justify-content, align-items등을 사용했는데, flex는 정말이지 유용하다. 아무 생각 없이 했던 것 중 하나가 &lt;code class=&quot;language-text&quot;&gt;{ display: absolute }&lt;/code&gt;를 남발한 것인데, 세부적인 div가 아닌 이상 전체적인 layout에 사용하는 것은 좋지 않은 것 같다. 페이지의 크기 변화에 망가지기 일쑤였고, width와 height의 추가, 수정을 할 때마다 확인해주어야 했기 때문이다.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;javascript&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;주어진 assignment는 ID와 Password에 2글자 이상 쳤을 때만 Button이 활성화되고 Submit이 이루어지게 하는 것이었다. 맨 처음에는 onchange event인 줄 알고, 계속 작업을 했는데 도무지 작동을 하지 않아 원인을 알 수가 없었다. 그러다 알게 된 사실은 React에서는 onchange이지만 javascript에서는 그냥 change라는 것이었다.&lt;br&gt;
하지만 change로 완성한 뒤에도 문제가 생겼다. 해당 input 박스에서 focus out 되어야만 함수가 작동한다는 것이었다. 찾아보니 focus에 관련한 자세한 event가 많았으며, input박스에서 일어나는 변화에 즉각 반응하는 event를 생성하려면 change가 아닌 input event가 필요하다는 것을 알게 되었다.&lt;/li&gt;
&lt;li&gt;사용한 방법은 크게 보면 두 가지이다. ID와 Password에 값이 없을 때는 false라는 상태 값을 부여하고, input event로 인해 true로 변경되었을 때, active라는 css값을 통해 버튼을 활성화 시키는 것이다. 쉽게 간과하고 넘어갈 수 있는 것은 활성화까지만을 목표로 접근한다는 점이다. 항상 활성화와 함께 비활성화는 어떻게 할 것인지, else에 관한 부분을 고려해야 한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&quot;2-main-page&quot;&gt;&lt;a href=&quot;#2-main-page&quot; aria-label=&quot;2 main page permalink&quot; class=&quot;anchor&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;&lt;strong&gt;2. Main Page&lt;/strong&gt;&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;main page를 만들고 난 뒤, 여러모로 느낀 점이 많았다. 첫번째는 전체적인 layout에 대한 설계 없이 머릿속으로만 구상하면서 만들다보니 완성한 뒤에 쓸모 없어 보이는 tag, 비효율적인 id, class, img와 background image 사이에서의 전무한 고민 등 여러가지 문제점을 많이 느꼈다.&lt;/p&gt;
&lt;p&gt;첫번째로 전체적인 구성을 어느정도 완성하지 않으면, tree구조로 이루어져 있는 HTML에서 자칫 불필요한 열대 우림을 만들 수 있다는 점이다. 더불어 tag 이름에 대한 충분한 고민이 없기 때문에 부정확하고, 직관적이지 않은 tag를 남발할 수 있다.&lt;/p&gt;
&lt;p&gt;두번째로 id와 class에 대한 사전 설계가 정말 중요한 것 같다. 오랜 기간 축적된 경험이 있다면 어느 정도 규모의 tree는 감당할 수 있겠지만 경험이 없는 상태에서 무작정 tree를 만들다보면 때론 불필요하고, 때론 직관적이지 않은 id, class를 만들게 되고 결국 후에 logic을 작성할 때 부메랑이 되어 돌아온다는 것을 알게 되었다. 또한 css의 작성 과정에서도 id, class의 점수값에 따른 반영 차이 때문에 중간에 id &amp;#x3C;-&gt; class를 변경해야 될 때도 있었는데, 다행히 복잡하지 않은 단순한 page였기에 가능한 것이지 실제로 프로젝트 중에 이런 일이 발생한다면 더 큰 일이 생기 수도 있겠다는 생각이 들었다.&lt;/p&gt;
&lt;p&gt;세번째로 아직 span이나 div에 background image / 그냥 image tag 사이에 어떠한 선택을 해야하는지에 대한 명확한 기준이 없다. 단순하게 HTML 안에서 img를 남발하다보니 ‘src’ 덕분에 코드 자체가 굉장히 지저분해지고 가독성이 많이 떨어져 보인다. dom으로 제어하는 부분이나, css 값을 적용하는 것에는 둘 사이에 큰 차이가 있다고 생각이 들지는 않았는데, 실제 instagram은 대부분의 image를 span의 background-image로 적용하고 있었다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;​&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Javascript&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;주어진 assignment는 검색 창에 한 글자씩 입력할 때, 연관 검색어 같은 창이 생성되면서 일치하는 글자에 색깔이 변하게 하는 것이었다.&lt;/li&gt;
&lt;li&gt;먼저 input 박스 밑에 숨겨둘 &lt;code class=&quot;language-text&quot;&gt;&amp;lt;li&amp;gt;&lt;/code&gt; 태그를 만들었다. 그리고 &lt;code class=&quot;language-text&quot;&gt;{ display: none }&lt;/code&gt;으로 숨겨두었다. 그리고 dom을 사용해서 유사 배열 형태로 값을 받은 뒤, foreach와 같은 method를 사용하기 위해 Array.from으로 배열로 바꾸어주었다.&lt;/li&gt;
&lt;li&gt;Login Page에서 배운 input event를 사용해 한 글자마다의 즉각적인 변화가 가능하도록 했다.
foreach를 통해 각각의 글자에 접근이 가능해졌고, 일치하는 문자열, 불일치하는 문자열로 나누었다.
innerHTML을 통해 ’&lt;span class=&quot;&quot;&gt;‘를 직접입력해 색깔이 변하는 span을 적용해주었다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;feedback&quot;&gt;&lt;a href=&quot;#feedback&quot; aria-label=&quot;feedback permalink&quot; class=&quot;anchor&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;&lt;strong&gt;Feedback&lt;/strong&gt;&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;기본 바탕 -&gt; 쓸데 없는 것은 무조건 쓰지 말아야 하고, 최대한 간결하고 짧은 코드로 html/css를 완성해야 한다.&lt;/li&gt;
&lt;li&gt;필요 없는 div는 쓰지 말아야 한다.&lt;/li&gt;
&lt;li&gt;caniuse.com -&gt; css나 event등의 browser별 지원 여부를 알려주는 페이지이다.&lt;/li&gt;
&lt;li&gt;flex는 나오지 얼마 되지 않았기 때문에 이것을 사용하지 않고도 할 줄 알아야 한다. flex는 보통 row로 정렬할 경우에 많이 사용한다. 세로 정렬은 block 기반 element일 경우 따로 지정하지 않아도 되기 때문에 필요없는 flex는 지양해야 한다.&lt;/li&gt;
&lt;li&gt;부모 기준으로 absolute를 쓰지 않아도 정렬이 가능한 경우, relative, absolute도 쓰지 않아도 된다.&lt;/li&gt;
&lt;li&gt;​form은 block / input, button은 none block 요소이다.&lt;/li&gt;
&lt;li&gt;다양한 tag를 알맞게 사용하는 것은 매우 중요하고, 효율적이고, 직관적인 html 작성이 가능하다.&lt;br&gt;
그러나 잘못된 tag는 오히려 혼란을 야기할 수 있으므로 미리 알아보고 적절한 곳에 활용하는 것이 중요하다.&lt;/li&gt;
&lt;li&gt;section는 말 그래도 section을 나눌 때 사용한다. 따로 css가 필요할 경우에는 class를 부여해서 적용한다. body 안의 전체를 section으로 감싸는 것은 어색하다.&lt;/li&gt;
&lt;li&gt;image를 감싸고 있는 불필요한 div, span은 제거한다.&lt;/li&gt;
&lt;li&gt;image에 관하여, 우선 img 태그와 background-image의 기능적인 차이는 거의 없다.&lt;/li&gt;
&lt;li&gt;구글에 검색될 수 있는 여지가 있는 것은 img 태그이다.&lt;/li&gt;
&lt;li&gt;css로 다루기 쉬운 것은 div, span의 background-image이다. 장, 단점이 있는 것 같다.&lt;/li&gt;
&lt;li&gt;img 태그는 가로, 세로 둘 중에 하나만 값을 주어도 자동으로 비율에 맞추어 적용한다. 오히려 따로 값을 줄 경우 이미지가 깨질 여지가 있다.&lt;/li&gt;
&lt;li&gt;일정한 길이와 넓이가 있는 box에 overflow: auto를 적용할 경우, 해당 크기보다 커졌을 때 스크롤 바를 만들 수 있다.&lt;/li&gt;
&lt;/ol&gt;</content:encoded></item></channel></rss>