---
title: "TIL_191111"
date: "2019.11.11"
template: "post"
draft: false
slug: "/posts/til_191111/"
category: "TIL"
tags:
  - "Project"
  - "Rebase"
  - "Unit Test"
description: "Things I've learned through project"
socialImage: ""
---

## **Unit Test**

- Test를 안 하면, 결국 사용자가 테스트하는 상황이 발생한다.
- 코드가 제대로 작동하는지 검증하는 테스트가 반드시 필요하다(개발 시간의 50%를 테스트를 개발하는데 할애하는 것이 좋다).
- 초반에 테스트를 제대로 작성하지 않으면 보수, 유지에 훨씬 더 많은 비용이 들어간다.

1. 3가지 방법

- UI Testing / End to End Testing : UI를 직접 띄워놓고 테스트하는 것, End와 End를 붙여놓고 테스트 하는 것. 비용이 많이 든다.
- Integration Testing : 실제로 서버를 띄워놓고 테스트하는 것. 위의 방법에 비해 규모는 작지만 그래도 비용이 많이 든다.
- Unit Testing : Unit, 즉 함수를 테스트하는 것이 Unit Test이다. 테스트하는 코드를 짜는 것이다.
- Testing Pyramid : E2E(10%) => Intrgration(20%) => Unit(70%) 테스트는 자동화가 필수이다.

2. 기본적인 개념 및 용어

- Test Case : 말그대로 테스트하는 경우들
- Fixture : 테스트를 진행할 때 필요한 테스트용 데이터 혹은 설정들(코드를 먼저 짤 때부터 유닛 테스트를 염두에 두고 짜야한다. 유닛 테스트가 쉬운 코드가 좋은 코드이다).

3. 테스트의 종류

- 0(예외 케이스)
- -1(테스트를 통과하지 않는 케이스)
- 1(테스트 통과의 케이스)

4. 테스트의 원칙

- 독립적이어야 한다. 모든 테스트 케이스는 독립적으로 작동해야 한다. 어떠한 테스트를 위해 다른 테스트가 필요하면 안 된다.
  - setUp, tearDown : seUp은 테스트 케이스가 실행되기 전에 실행되는 것, tearDwn은 테스트 케이스 후에 데이터를 지우는 것

## **Rebase**

feature branch에서 작업을 하다가 master branch로 merge, 최종 master branch에는 내가 커밋한 상황들이 커밋한 시간 기준으로 중간 중간 섞여 들어가게 된다.

그렇게 되면 하나의 기능에 대해 추적이 힘들다(커밋이 나뉘어져 있기 때문에).

만약 내 기능이 틀려서 다시 원복해야 하는 경우에 매우 힘들다.

이를 해결하기 위해 나온 기능이 Re-base, squash이다.

merge 대신에 Rebase를 한다. 즉, 커밋한 시점을 모두 rebase해서 내가 merge한 뒤로 붙여버리는 것이다.

squash는 여기서 한 기능에 대해 모든 commit을 합쳐서 하나의 feature로 만든 것이다. => 한 기능을 한 눈에 보기 편하고, 되돌리기에 용이하다.

git rebase -i // rebase interactive
