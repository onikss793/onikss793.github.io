---
title: "TIL_191114"
date: "2019.11.14"
template: "post"
draft: false
slug: "/posts/til_191114/"
category: "TIL"
tags:
  - "Project"
  - "Data Structure"
description: "Things I've learned through project"
socialImage: ""
---

## **Data Structure**

데이터의 타입에 따라 효율적으로 저장하기 위한 도구이다.

자료구조가 중요한 이유는 데이터 처리 자체가 중요하기 때문이다.

Primitive: Integer, Float, String, Boolean

Non-Primitive: Array, List, Tuple, Dictionary, Set, File

#### Array

- 배열, 물리적으로 메모리에 순차적으로 저장이 된다. 순서가 있기 때문에, 지표인 index가 있고, 이를 통해 특정 자료에 바로 접근할 수 있다.
- 순서가 있는 데이터를 저장할 때, 유용하다.
- 물리적으로 저장되는 위치가 정해져 있기 때문에, 항상 일정량의 메모리를 차지하고 있다.
- 만약 물리적 크기가 다 차게 되면, 더 큰 메모리를 확보한 후, 기존의 배열을 복사해서 새로운 요소를 추가한다.
- 위의 것을 RESIZING이라고 하며, 이것이 단점이다.
- 순차적 조회를 할 경우 속도가 빠르지 않다. O(N) : 해당 자료구조의 사이즈에 비례한다는 뜻.
- 직접적 조회를 할 경우, O(1)
- 순차적, 특정 요소, 사이즈 급변 X, 요소 삭제 X 일 경우에 사용하면 좋다.

#### Tuple

- 순차적인 자료 구조이다.
- 한번 생성하면 수정할 수가 없다.
- 배열보다 메모리 효율적이다.
- 튜플을 사용하지 않을 경우, 별도의 클래스를 생성해야 하는 수고를 덜 수 있다.
- 테스트용, 즉 사용하긴 하지만 크게 중요하지 않은 데이터를 저장할 때 유용하다.

#### Set

- 배열과 비슷한 순열 자료구조이다.
- 하지만 순서가 없다.
- 그래서 index도 없다.
- 중복된 값이 허용되지 않는다.
- 중복된 값을 제거하는 방식은, 입력된 값을 해싱한 후 자료 버켓에 넣고 중복된 값이 들어올 경우, 치환한다.
- 치환하는 이유는 데이터의 identification의 문제는 쉬운 것이 아니다.
- class의 경우 default로 메모리의 주소를 기준으로 비교한다.
- 특정한 값을 찾는 속도가 매우 빠르다.
- 중복된 값을 골라내야 할 때, 빠른 조회가 필요할 때, 순서는 상과 없을 때 사용하면 좋다.

#### Stack

- First in Last Out: 선입후출
- 밑단에는 array로 구현되어 있다.

#### Queue

- First in First out: 선입선출
- priority que: 중요도가 높은 큐를 먼저 뺄 때 사용
- 밑단에는 array로 구현되어 있다.

#### Tree

- 어려운 트리구조도 많다.
- 기본적으로는 binary 트리이다. 노드: 트리의 교점
- 노드보다 값이 클 경우, 오른쪽, 작을 경우, 왼쪽으로 간다.
- 리스트보다 훨씬 빠르다. O(logN) 속도

#### Linked List

- 메모리가 충분하거나, 데이터의 정확한 사이즈를 모르겠거나, resizeing이 굉장히 큰 문제이거나, 중간에 삭제해야할 경우가 많을 때 사용하면 좋다.
