---
title: 'TIL_191207'
date: '2019.12.07'
template: 'post'
draft: false
slug: '/posts/til_191207/'
category: 'TIL'
tags:
  - 'typescript'
description: 'Introduction to typescript'
socialImage: ''
---

**Array**

배열을 작성하는데는 두 가지 방식이 있다.

첫번째로, element의 타입 뒤에 []를 작성하면 된다.

```ts
const list: number[] = [1, 2, 3];
```

두번째는 Array 타입을 적는 방식이 있다.

```ts
const list: Array<number> = [1, 2, 3];
```

**Tuple**

튜플은 정해진 숫자의 element의 타입을 모두 지정해야 한다.

```ts
const x: [string, number];
x = ['hello', 10]; // OK
x = [10, 'hello']; // error
```

**Enum**

enum을 활용하면 순서가 있는 세트의 타입을 지정할 수 있다.

```ts
enum Color {
  Red,
  Green,
  Blue,
}

const c: Color = Color.Green;
```

맨 앞에서 부터 기본적으로 0부터 시작한다. 그리고 직접 숫자를 변경하는 것도 가능하다.

```ts
enum Color {
  Red = 1,
  Green = 3,
  Blue = 8,
}
const c: Color = Color.Green;
```

**Any**

어떤 타입이 올지 모를 경우, any라는 타입을 지정해 줄 수 있다.

```ts
const notSure: any = 4;
notSure = 'maybe a string instead';
notSure = false;
```

**Void**

any와는 다르게 그 어떠한 타입의 값도 반환하지 않을 경우에 주로 사용한다.

```ts
function greet(): void {
  console.log('Hello!');
}
```

**Never**

never은 끝에 도달하지 않는 함수에 사용한다.

```ts
function error(message: string): never {
  throw new Error(message);
}

function fail() {
  return error('Something failed');
} // type: never

function infiniteLoop(): never {
  while (true) {}
}
```

**Object**

object는 원시 타입이 아닌, 즉 `number, string, boolean, bigint, symbol, null, undefined`를 제외한 모든 타입을 말한다.

API를 표현할 때 유용할 수 있다.

```ts
declare function create(o: object | null): void;

create({ prop: 0 }); // OK
create(null); // OK

create(42); // Error
create('string'); //Error
create(false); // Error
create(undefined); // Error
```

**Type assertions**

타입스크립트에서 지정한 타입보다 더 정확한 타입을 내가 알고 있을 경우, 두 가지의 방식으로 이를 더 정확히 표현할 수 있다.

```ts
const someValue: any = 'this is a string';

const strLength: number = (<string>someValue).length;
```

이처럼 `<type>`를 사용해서 지정하는 것이 가능하다.

```ts
const someValue: any = 'this is a string';

const strLength: number = (someValue as string).length;
```

두 가지 모두 사용해도 상관 없으나 JSX를 사용하는 경우 as 문법만 사용 가능하다.

### **Destructuring**

Array

```ts
const input = [1, 2];

const [first, second] = input;

console.log(first); //1 === first = input[0]
console.log(second); //2 === second = input[1]
```

배열의 비구조화는 일반 자바스크립트와 크게 다르지 않다.

이것을 사용하면 타입을 지정하는 것에도 응용할 수 있다.

```ts
function func([first, second]: [number, number]): void {
  console.log(first);
  console.log(second);
}

f([1, 2]); // 1, 2
```

Rest Parameter를 사용하는 것도 가능하다.

```ts
const [first, ...rest] = [1, 2, 3, 4];

console.log(first); // 1
console.log(rest); //[2, 3, 4 ];
```

**Tuple**

튜플은 배열과 비구조화가 비슷하다. 하지만 각각의 요소에 맞는 타입을 모두 지정해줘야 한다.

```ts
const tuplle: [nu, ber, string, boolean] = [7, 'hello', true];

const [a, b, c] = tuple; //a: number, b: string, c: boolean
```

하지만 튜플의 길이보다 큰 것은 비구조화할 수 없다.

```ts
const [a, b, c, d] = tuple; // Error
```

**Object**

객체 비구조화도 기본 자바스크립트와 매우 유사하다.

```ts
const o = {
  a: 'foo',
  b: 12,
  c: 'bar',
};

const { a, b } = o;
```

**Function**

함수에도 비구조화를 적용할 수 있다.

```ts
type C = { a: string; b?: number };

function f({ a, b }: C): void {
  // ...
}
```

### **Spread**

Spread는 비구조화의 정반대의 개념이라고 보면 쉽다.

예를 들어,

```ts
const first = [1, 2];
const second = [3, 4];
const both = [0, ...first, ...second, 5];
```

이렇게 작성할 경우 `console.log(both) //[0, 1, 2, 3, 4, 5]`가 된다.

객체에서도 동일하게 사용 가능하다.

```ts
const default = { food: 'spicy', price: '$', ambiane: 'noisy' };
const search = { ...defaults, food: 'rich' };
console.log(search) // { food: "rich", price: "$$", ambiance: "noisy" }
```

class에도 적용하면 class를 복제해서 사용할 때 유용하게 사용할 수 있다.

```ts
class C {
  p = 12;
  m() {}
}

const c = new C();
const clone = { ...c };

clone.p; // OK
clone.m(); // ERROR
```

하지만 위처럼 내제되어 있는 함수는 spread할 수 없다.
