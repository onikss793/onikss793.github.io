---
title: "TIL_191112"
date: "2019.11.12"
template: "post"
draft: false
slug: "/posts/til_191112/"
category: "TIL"
tags:
  - "Project"
  - "Rebase"
description: "Things I've learned through project"
socialImage: ""
---

## **Git Rebase**

1. git rebase -i : 어디서 실행하느냐가 중요하다.
   - 현재 내 branch를 파악
   - 현재 내 branch가 아닌 곳에서 rebase를 실행할 것이라면 git rebase -i master feature/login 이런 식으로 브랜치를 적어주어야 한다.
2. 내가 맨 처음 커밋한 곳을 기점으로 밑으로 squash를 적어주어야 한다. 약자는 s
3. commit message가 쭉 뜨는 창을 볼 수 있다. (conflict가 뜰 수도 있다)
   - conflict를 방지하기 위해, push를 할 준비가 되었다면, 항상 pull을 먼저 한 뒤에 conflict를 해결하고 rebase를 진행하는 것이 좋다.
4. merge 이전에 수정 사항을 적용하고, 다시 commit을 했다면, push할 때 -f 를 사용해서 강제로 push를 해야 한다.
5. rebase 중간에 어찌해야할지 몰라 중단하고 싶을 때는 git rebase --abort 를 치면 된다.

## **1차 프로젝트에 대하여**

1. 폴더 대, 소문자 규칙을 정해서 정해야 한다. 폴더의 이름은 보통 소문자로 하고, 컴포넌트의 이름은 대문자로 만든다.
2. noramlize.css, common.css, reset.css 따로 만들어서 각각, 크로스 브라우징, 공통 스타일, 초기화 세팅을 맞춘다.
3. 공통적으로 사용할, key 같은 고정 값들은 config.js에 항상 constant로 선언해서 사용하는 것이 좋다.
4. 절대경로, 상대경로 하나만 통일해서 사용하는 것이 좋다.
5. Route에 경로를 설정할 때는 항상 간단하게 하는 것이 좋다. 만약 로그인 전,후로 나뉘어야 한다면 pages에 로직으로 처리하도록 한다.
6. 로그인 유무를 체크하는 함수는 공통적으로 많이 쓰이는 함수이다. 이와 같은 함수들은 utils에 common.js에 따로 저장해서 사용하면 된다.
7. 컴포넌트 폴더에는 말그대로 재사용 가능한 것들만 있어야 한다. 해당 페이지에서만 재사용할 것들은 pages 밑에 폴더를 만들어서 사용한다.
8. import 하는 순서, 리엑트, config, 컴포넌트, 마지막으로 css 이다.
9. state 안에서 props를 사용할 필요가 없으면, 굳이 constructor를 쓰지 않고 state를 써도 된다.
10. componentDidMount에서 전역에 이벤트를 등록했다면 componentDidUnmount 안에 이벤트를 삭제하는 코드를 적어야 한다.
11. `this.intervalId = this.setInterval(() => {}, 1000) // clearInterval(this.intervalId)` 이런식이 되어야 한다.
12. `const { data: { data } } = this.state;`이런 식의 비구조화 할당도 가능하다.

## **Node.js Data Crawling**

왜 옛날과 지금의 크롤링 방식이 다를까. 옛날에는 html에 모든 데이터를 심어서 클라이언트에 넘겨주었기 때문에, html 안에 모두 있었다.  
그래서 옛날에는 백엔드 개발자가 html에 데이터를 심어두기만 하면 되었다.  
AJAX를 통한 비동기 통신 때문에 사용자와 상호 작용하며 호출하는 api들에 의한 데이터 추가 방식도 있다.  
리액트를 사용할 경우, index.html이 자바스크립트를 통한 컴포넌트를 불러오면서 형성이 된다.  
그렇기 때문에 SPA의 경우 크롤링 했을 때, 그냥 div 하나만 있는 경우가 많다.  
즉, 클라이언트 사이드 렌더링이기 때문에 데이터를 가져오기가 힘들다.  
next.js의 경우 서버 사이드 렌더링이 가능하다.(구글의 경우는 클라이언트 사이드 렌더링이어도 그 안에 있는 자바스크립트를 모두 호출해서 데이터를 갖고 올 수 있다고 함.)

phantom.js selenium을 사용한다. 마치 사용자가 직접 브라우저를 제어하는 것과 같은 방식으로 크롤링을 한다.

graphql은 엔드포인트가 하나다. 모든 페이지에서 통하는 api는 딱 하나인 것이다. 그렇다면 무엇으로 다른 요청을 보낼까. 바로 body에 담겨있는 query이다. 이 query는 프론트엔드에서 보내는 것이다.

```
fragment CollectionSummary on Collection
{↵  _id↵  firestoreId↵  periodDescription↵  startAt↵  endAt↵  heroImageUrl↵  title↵  promotionId↵  type↵  score↵  description↵  isHidden↵  itemType↵  itemIds↵  __typename↵}↵↵query CollectionSummaryByIds($collectionIds: [String!]!) {↵  collections: collectionsByIds(ids: $collectionIds) {↵    ...CollectionSummary↵    __typename↵  }}
```

api 크롤링해서 db에 넣는 것까지 하면 된다.

1. axios를 깐다.
2. 프론트엔드에서 자바스크립트의 런타임 환경은 브라우저이다. node는 chrome의 v8엔진을 사용해서 브라우저에서 돌아간다. node를 사용할 때의 자바스크립트가 돌아가는 환경은 node이다. node는 그저 자바스크립트가 작동하는 런타임 환경일 뿐이다. node를 사용하기에 좋게 만드는 것이 express와 같은 웹프레임워크이다.

```js
axios.post("https://gql-prod.class101.net/graphql").then(res => {
  console.log(JSON.stringify(res.data, null, 2));
});
```

이렇게 하면 index.html에 아무것도 나오지 않게 된다.

```js
axios
  .post("https://gql-prod.class101.net/graphql", {
    operationName: "CategorySummaryList",
    query: `fragment CategorySummary on Category {
      _id
      firestoreId
      title
      iconUrl
      __typename
  }
  
  query CategorySummaryList($categoryFilter: PreCategoryFilter!, $limit: Int, $offset: Int) {
      categories: getCategories(categoryFilter: $categoryFilter, limit: $limit, offset: $offset) {
        ...CategorySummary
        __typename
    }
}
  `,
    variables: {
      categoryFilter: { isHide: false },
      offset: 0,
      limit: 9999
    }
  })
  .then(res => {
    console.log(JSON.stringify(res.data, null, 2));
  })
  .catch(err => console.log(err));
```

위의 코드에서 post에서의 두번째 인자로 query 정보를 추가하면 된다. 이 정보는 사이트에서 network의 http body에서 찾을 수 있다.
