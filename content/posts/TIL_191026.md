---
title: "TIL 191026"
date: "2019.10.26"
template: "post"
draft: false
slug: "/posts/til_191026/"
category: "TIL"
tags:
  - "TIL"
  - "Django"
description: "What I learned today"
socialImage: ""
---

django에서 암호화에 대해 공부하다 보니 드는 의문점들을 정리해보았다.

### 해싱이란?

대부분의 탐색 방법들은 탐색 키를 저장된 키 값과 반복적으로 비교하면서(반복문의 개념) 탐색을 원하는 항목에 접근한다.

반면 해싱은 키 값(배열의 인덱스라고 생각하면 된다)에 직접 산술적인 연산을 적용하여 항목이 저장되어 있는 테이블의 주소를 계산하여 항목에 접근한다.

이렇게 키 값의 연산에 의해 직접 접근이 가능한 구조를 해시 테이블(hash table)이라 부르고, 해시 테이블을 이용한 탐색을 해싱(hashing)이라 한다.

**해시 함수**란 탐색 키 *(인덱스의 역할을 하지만 문자열이거나 굉장히 큰 숫자이기 때문에 바로 인덱스로 활용하기에는 문제가 있다)*를 입력으로 받아 **해시 주소**를 생성하고 이 해시 주소가 **배열로 구현된 해시 테이블**의 인덱스가 된다.

이 배열의 인덱스 위치에 자료를 저장할 수도 있고 저장된 자료를 꺼낼 수도 있다.

_(예를 들어 영어 사전을 배열 hashTable[]에 저장한다고 하면 단어을 해싱 함수를 이용하여 적절한 정수 i로 변환한 다음, 배열 요소 hashTable[i]에 단어의 정의를 저장하는 것이다)_

**궁금증**

- 해싱하기 전, 바이트화 하는 이유는?

- 바이트한 후 해싱을 했다. 그렇다면 db에 저장할 때 다시 디코딩하는 이유는?

---

아래는 장고 서버와 다른 서버가 통신할 때 필요한 django cors 기본 세팅이다. 참고로 모든 서버에 오픈되어 있다.

```py
CORS_ALLOW_HEADERS = [
      'accept',
      'accept-encoding',
      'authorization',
      'content-type',
      'dnt',
      'origin',
      'user-agent',
      'x-csrftoken',
      'x-requested-with',
]

CORS_ORIGIN_ALLOW_ALL = True

CORS_ALLOW_CREDENTIALS = True
```

### **Fetch**

백앤드 서버, 프론트 앤드의 서버가 각각 필요하다. 백앤드 서버의 ip주소를 알면 프론트 앤드 서버에서 해당 ip 주소를 통해 api를 호출할 수 있다.

자바 스크립트는 비동기로 작동하기 때문에 fetch를 하게 되면 응답을 기다리기 전에 다른 함수로 넘어간다. 여기서 then을 쓰게 되면 fetch의 응답을 기다렸다가 then()안에 있는 함수를 실행시킨다.

```js
login = () => {
  fetch("http://localhost:8000/account/login", {
    method: "post",
    body: JSON.stringify({
      user_name: this.state.idValue,
      password: this.state.pwValue
    })
  })
    .then(res => res.json())
    .then(res => {
      const { history } = this.props;
      if (res.message === "success") {
        localStorage.setItem("userToken", res.token);
        history.push("/main");
      } else {
        window.location.reload();
      }
    });
};
```

then()안에 있는 json()함수를 사용하면 body에 있는 내용만 json 형태로 변환된다. 그 다음의 then 함수 안에 있는 함수를 통해 원하는 작업을 할 수 있다.

만약 백앤드 서버에서 200을 보내면 그것을 조건으로 삼아서 로컬 스토리지 등에 토큰을 저장하고 메인 페이지(다음 페이지)로 넘어갈 수 있다.

로그인하는 시점에서 백엔드 서버에서 토큰을 발행 받는다. 그리고 브라우저의 local storage, session storage cookie에 각각 기획의 특성에 맞게 저장한다.

그리고 로그인 상태에서 하는 액션에 대해 api 요청을 보낼 때마다 header에 토큰을 담아서 보내, 백앤드 서버에서 사용자를 구분할 수 있도록 한다.

Authorization 이라는 key에 담아서 토큰을 보낸다.

```js
updateComments = () => {
  fetch("http://localhost:8000/main", {
    method: "post",
    headers: { Authorization: localStorage.getItem("userToken") },
    body: JSON.stringify({
      comment_text: this.state.comments.desc
    })
  })
    .then(res => res.json())
    .then(() => this.getComments());
};
```

comment를 데이터 베이스에 업로드 하고 이어서 getComment 메서드를 다시 실행시켜 새로운 comment도 render시킨다.

```js
getComments = () => {
  fetch("http://localhost:8000/main")
    .then(res => res.json())
    .then(res => {
      this.setState({ commentInfo: res });
    });
};
```
