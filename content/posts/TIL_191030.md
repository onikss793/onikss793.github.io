---
title: "TIL 191030"
date: "2019.10.30"
template: "post"
draft: false
slug: "/posts/til_191030/"
category: "TIL"
tags:
  - "TIL"
  - "Database"
description: "What I learned today"
socialImage: ""
---

## **Database**

Database는 데이터를 저장 및 보존하는 시스템이다.

Database를 사용하지 않으면

- 첫째로 메모리에 저장할 수가 있다. 하지만 그렇게 할 경우, 속도는 빠르지만 영구 보존이 안 된다.
- 둘째로 파일에 저장할 수 있다. 그렇게 하면, 효과적인 데이터 저장이 힘들어진다. (ex: 어제 작업한 것 중, 어떤 특정 단어만 업데이트할 경우 매우 힘들어진다) 그리고 파일의 용량이 커질 경우 속도가 매우 느려질 수 있다.
- 결과적으로 영구 보존을 하면서 효과적인 데이터 저장을 위해 데이터 베이스를 사용한다.

### **관계형 데이터베이스(RDBMS, Relational DataBase Management System)**

- 데이터 테이블을 나누는 기준을 설정하는 것이 백앤드 개발자의 역할이다.
- 데이터를 테이블을 기준으로 나누는데 행과 열로 나눌 수 있다.
- 각각의 테이블은 컬럼(column)과 row(로우)로 구성된다.
  - 서로 연결되어 있는 key를 foreign key라고 한다. 이 foreign key는 실제 존재하는 값이여야만 한다. 존재 하지 않는 데이터는 참조할 수가 없다.
  - 컬럼은 테이블의 각 항목을 말한다. 행으로 생각하면 된다.
  - 로우는 각 항목들의 실제 값들을 이야기 한다. 열로 생각하면 된다.
  - 각 로우는 저만의 고유 키(Primary Key)가 있다. 주로 이 primary key를 통해서 해당 로우를 찾거나 인용(reference)하게 된다.
    - PM key를 쓰는 이유는, 컨텍스트가 있는 값들은 변할 가능성이 있기 때문에 변하지 않는 고유한 값을 주는 것이다.(surrogate, natural gate)
- 데이터를 왜 관계형으로 연결하는가?
  - 데이터 완전성 때문이다.
  - 데이터가 틀릴 가능성을 아주 줄여준다.

### **트랜잭션(Transaction)**

- ACID를 제공함으로 따라서 트랜잭션(일련의 작업들을 한번에 하나의 unit으로 실행하는것) 기능을 제공하다.
- 트랜잭션은 일련의 작업들이 마치 하나의 작업처럼 취급되어서 모두 다 성공하거나 아니면 모두 다 실패하는걸 이야기 한다.
- Commit & rollback
  - 마치 은행에서 이체를 하는 과정과 같다. 이체에 필요한 모든 과정을 다 하나의 과정으로 묶고 그 과정 중, 하나만 실패하면 처음 과정이 실행하기 전으로 돌아가는 것을 말한다.

### **SQL**

**SELECT**  
데이터를 읽어 들일때 사용

```
SELECT
    id,
    name,
    age,
    gender
FROM users
```

**WHERE** 구문을 사용해 검색도 가능

```
SELECT
    id,
    name,
    age,
    gender
FROM users
WHERE name = "아이유"
```

**INSERT**  
데이터를 생성할때 사용

```
INSERT INTO users (
    id,
    name,
    age,
    gender
) VALUES (
    1,
    "아이유",
    27,
    "여자"
), (
    2,
    "제인",
    19,
    "여자"
)
```

**UPDATE**  
데이터를 수정할때 사용
`UPDATE users SET age = 25 WHERE name = "아이유"`

**DELETE**  
데이터를 삭제할때 사용  
`DELETE FROM users WHERE gender = "남자"`
**Exist**  
어떠한 조건이 존재 하는지 하지 않는지 확인 할때 사용하는 SQL 문.  
예를 들어, 특정 user_name이 이미 존재하는지 확인 하고 싶을 때

```
SELECT 1
FROM users
WHERE EXISTS (SELECT *
              FROM users
              WHERE user_name = '아이유');
NOT EXIST 를 사용하여 반대의 경우도 체크 할 수 있다.
SELECT lname, fname
FROM customer
WHERE NOT EXISTS (SELECT *
                  FROM orders
                  WHERE customers.customer_id = orders.c_id);
```

**Join**  
Foreign key(외부키)로 걸려있는 2개의 table들을 join(연결)해서 양쪽 table에서 모두 row를 읽어 들이고 싶을 때는 join 문을 사용해야 함.  
즉, join은 교집합 이라고 생각하면 된다.  
Join 기본 문법

```
SELECT
테이블별칭.조회할칼럼,
테이블별칭.조회할칼럼
FROM 기준테이블 별칭
INNER JOIN 조인테이블 별칭 ON 기준테이블별칭.기준키 = 조인테이블별칭.기준키
```

Join 실제 예

```
SELECT
  users.id,
  users.name,
  users.age,
  users.gender,
  accounts.account_type
FROM users
JOIN accounts ON accounts.id = users.account_id
```

join 여러 유형들

- (INNER) JOIN: 일반적인 join문. 기준이 되는 테이블 (left table)과 join이 걸리는 테이블(right table) 양쪽 모두에 matching되는 row만 select가 됨.
- LEFT (OUTER) JOIN: 기준이 되는 테이블 (left table)의 모든 row와 join이 걸리는 테이블(right table)중 left table과 matching되는 row만 select가 됨.
- RIGHT (OUTER) JOIN: join이 걸리는 테이블(right table)의 모든 row와 기준이 되는 테이블 (left table)에서 right table과 matching되는 row만 select가 됨.
- FULL (OUTER) JOIN: 기준이 되는 테이블 (left table)과 join이 걸리는 테이블(right table) 양쪽 모두의 모든 row를 select 한다.

**CREATE TABLE**  
테이블을 생성할때 사용

```
CREATE TABLE accounts(
id INT NOT NULL AUTO_INCREMENT,
account_type VARCHAR(100) NOT NULL,
PRIMARY KEY (id)
);

CREATE TABLE users(
id INT NOT NULL AUTO_INCREMENT,
name VARCHAR(255) NOT NULL,
email VARCHAR(255) NOT NULL,
hashed_password VARCHAR(255) NOT NULL,
account_id INT NOT NULL,
PRIMARY KEY (id),
UNIQUE KEY email (email),
CONSTRAINT `users_account_fkey` FOREIGN KEY (`account_id`) REFERENCES `accounts` (`id`)
);
```
