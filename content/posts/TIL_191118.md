---
title: "TIL_191118"
date: "2019.11.18"
template: "post"
draft: false
slug: "/posts/til_191118/"
category: "TIL"
tags:
  - "Project"
  - "Node.js"
description: "Things I've learned through project"
socialImage: ""
---

## **Folder Structure**

Node.js로 서버를 생설할 때, 몇 가지 웹 프레임워크를 사용하면 빠르게 백앤드 서버를 구축할 수 있다. 그 중에서 가장 많이 쓰이는 것이 express이다. 하지만 django와 다르게 이용자에게 강제하는 Folder Structure이 없기 때문에 어떤 식으로 구조를 짜느냐에 따라, 코드, 로직이 달라질 수 있다.

이번 프로젝트에서는 app.js와 server.js를 제외하고 크게 models, routes, controllers, services, middleware 나누었다.

### **models**

데이터 베이스로 mongo db를 사용했다. mongoose를 사용해 모델의 스키마를 생성할 수 있다. models 폴더 안에 각각의 모델들을 mongoose.Schema를 이용해 구조를 짜면 된다.

```js
const mongoose = require("mongoose");
const Schema = mongoose.Schema;

const categorySchema = new Schema({
  _id: { type: Schema.Types.ObjectId },
  title: { type: String, required: true },
  iconUrl: { type: String, required: true }
});

module.exports = mongoose.model("Category", categorySchema);
```

\_id는 mongoose에서 기본적으로 생성해준다. 하지만 위의 경우, 데이터 크롤링할 때 반드시 일치해야하는 아이디가 있어 직접 적어주었다.

`{}` 안에 여러 옵션들이 있다. 위에서 사용한 것은 가장 자주 사용할 법한 것들이고, 이외에도 많은 옵션이 있음으로 적절히 사용하면 효과적으로 스키마를 짤 수 있다.

### **routes**

폴더 내의 index.js에서 각 endpoint에 해당하는 경로를 설정해 줄 수 있다.

다음은 index.js이다.

```js
const categoryRouter = require("./category");
const bannerRouter = require("./banner");
const collectionRouter = require("./collection");

const router = app => {
  app.use("/category", categoryRouter);
  app.use("/banner", bannerRouter);
  app.use("/collection", collectionRouter);
};

module.exports = router;
```

보다시피 router를 하나의 function으로 만들었다. `express.router()`이 아니라 그냥 함수이다.

app.js 에서 이 함수를 이용해 `routes(app)`를 통해 모든 경로를 실행해 줄 수 있다. app.js에서 무수히 많아질 수 있는 routes를 효과적이고, 가독성 높게 해결할 수 있는 방법이다.

다음은 categoryRouter의 코드이다.

```js
const express = require("express");
const router = express.Router();
const categoryController = require("controllers/category");

router.get("/", categoryController.list);

router.get("/:categoryId", categoryController.single);

module.exports = router;
```

RESTful 엔드포인트를 효과적으로 정리해서 파악할 수 있다. category에 해당하는 모든 api요청은 `http://ip/category`에 이어서 작성해주면 되는 것이다.

### **controllers**

controllers는 데이터 베이스와 비즈니스 로직을 연결하는 역할을 한다. 비즈니스 로직이란 요청을 받는 순간에서부터 응답을 보내는 사이의 로직을 말한다.

간결하게 처리하기 위해 services라는 폴더를 만들어 비즈니스 로직을 모아 두었다.

그래서 controllers에는 요청과 응답만을 최대한 간결하게 작성하도록 했다.

```js
exports.single = async (req, res) => {
  try {
    const categoryId = req.params.categoryId;
    const response = await services.getProductByCategory(categoryId);

    res.status(200).json({ data: response });
  } catch (err) {
    res.status(500).json({ error: err.message });
  }
};
```

위에서 볼 수 있듯이 요청에 대한 응답을 이끌어내는 비즈니스 로직은 따로 분리해 반환한 값만을 이용한다.

### **services**

services에는 비즈니스 로직을 분리해두면 된다.

```js
const Product = require("models/product");
const common = require("common");

exports.getProductByCategory = async categoryId => {
  const products = await Product.find({ categoryId: categoryId }).select(
    "title _id coverImageUrl wishlistedCount feedbackCount feedbackGoodCount willOpenAt "
  );

  return common.getResponseForList(products);
};
```

services에서 try, catch를 이용해 에러를 헨들링할 수도 있겠지만, 이 외에도 요청부터 응답 사이에 여러가지 이유로 에러가 날 수 있기 때문에 services에는 최대한 로직만을 간결하게 작성하도록 한다.

추가적으로 반복적으로 사용할 함수는 common.js에 따로 빼어 공통적으로 사용할 수 있도록 했다(효율적인 방법인지는 모르겠음).
