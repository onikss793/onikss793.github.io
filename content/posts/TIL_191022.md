---
title: "TIL 191022"
date: "2019.10.22"
template: "post"
draft: false
slug: "/posts/til_191022/"
category: "TIL React Native Algorithm"
tags:
  - "TIL"
  - "React Native"
  - "Algorithm"
description: "What I learned today"
socialImage: ""
---

### _React Native_

1. React Native에서는 li처럼 반복되는 element를 생성하기 위해, map 함수 대신 flatlist라는 태그를 사용할 수 있다.\

   ```js
   import { FlatList } from "react-native";
   ```

   react-natve에서 import해서 사용하면 된다.

   ```js
   <FlatList
     data={commentsData}
     renderItem={({ item }) => (
       <View style={comment}>
         <Text style={user}>{item.userId}</Text>
         <Text style={desc}>{item.desc}</Text>
       </View>
     )}
     style={list}
   />
   ```

   FlatList에는 data 라는 property를 사용해서 render할 배열을 지정해줘야 한다.  
    이어서 renderItem을 사용해 item이라는 인자를 활용하면, 배열 안에 있는 요소 하나씩 받아 쓸 수 있다. 주의해야할 것은 저 item대신 다른 것을 쓰면 안 된다는 점이다.

2. React Native에서도 React와 마찬가지로 state에 저장되어 있는 상태 값 중, 배열에 어떠한 요소를 추가할 때는 push대신 concat을 써야 한다. push의 리턴 값은 새로 추가한 요소이기 때문에 push를 하게 되면 방금 추가한 요소 한 가지만 render가 될 것이다.

   ```js
   <CommentInput
     createComment={inputVal => {
       const { commentsData } = this.state;
       let newComment = {};
       newComment["userId"] = "wecode_bootcamp";
       newComment["desc"] = inputVal;
       this.setState({
         commentsData: commentsData.concat(newComment)
       });
     }}
   />
   ```

3. internal server error 500 일 때는 path 지정이 잘못되었을 가능성이 높다. (node_modules에서 찾지 못함). 수정 했는데도 에러가 없어지지 않을 경우 자체 서버 에러일 수도 있기 때문에 서버를 종료했다가 다시 키면 된다.

4. input 박스처럼 보이는 View를 press 하면 component가 TextInput으로 바뀌면서 포커스가 강제로 주어져 키보드가 올라오도록 했고, 키보드가 올라옴에 따라 정확히 TextInput 박스에서 멈춰야 한다.

5. FlatList의 keyExtractor는 string 타입의 고유한 id를 받아야 한다. 중복되거나 숫자가 들어갈 경우 경고 메시지를 받을 수 있다.

6. React Native에는 자체 button이 있기는 하지만 customizing이 불가능하기 때문에 대부분의 경우 쓰지 않고, touchableOpacity를 쓴다고 한다.

### _Algorithm 접근 방식_

1. 문제를 먼저 이해해야 한다. 이해했다면 확인하는 작업까지 이어져야 한다.

   - 문제를 이해하는 방식은 먼저 input과 output으로 정리하면 명확하다.

2. 코드를 치는 것은 제일 마지막에 해야 한다. 무엇을 짤 것인가에 대한 명확한 이해가 선행되어야 한다. 즉, Solution을 먼저 생각해야 한다.

   - 시작점부터 생각하면 대부분 맞다.

   - 문제를 비록 해결하지 못하더라도 나의 사고 과정을 계속해서 이야기하는 것이 중요하다.

   - 알고리즘 면접을 볼 때, 면접관과 자신의 케미스트리, 호감도를 상승시키는 것이 중요하다. 단순히 알고리즘 문제를 잘 해결하는 것과는 별개의 문제이다.

3. 마지막으로 디버깅, 테스트하는 과정을 보여주어야 한다. 문제를 다 풀고나서 테스트하는 과정을 보여주고 틀렸다면 수정하는 모습까지 보여주는 것이 중요하다. 만약 디버깅이 맞고 틀리고의 문제가 아니라 테스트까지 하는 것, 그 자체가 더 중요하다.

```js
// 시작점: n
// if n % 2 !== 0 을 기준으로, yes or no => 소수, 소수X
// 만약 no라면 그 다음 숫자, 3으로 나누고, 그 다음이면 4... n % n - 1 까지 간다.
```
